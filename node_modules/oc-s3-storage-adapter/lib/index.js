"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const client_s3_1 = require("@aws-sdk/client-s3");
const node_http_handler_1 = require("@aws-sdk/node-http-handler");
const nice_cache_1 = __importDefault(require("nice-cache"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const node_dir_1 = __importDefault(require("node-dir"));
const lodash_1 = __importDefault(require("lodash"));
const util_1 = require("util");
const oc_storage_adapters_utils_1 = require("oc-storage-adapters-utils");
const path_1 = __importDefault(require("path"));
const getPaths = (0, util_1.promisify)(node_dir_1.default.paths);
const streamToString = (stream) => new Promise((resolve, reject) => {
    const chunks = [];
    stream.on('data', chunk => chunks.push(chunk));
    stream.on('error', reject);
    stream.on('end', () => resolve(Buffer.concat(chunks).toString('utf8')));
});
function s3Adapter(conf) {
    const isValid = () => {
        if (!conf.bucket ||
            !conf.region ||
            (conf.key && !conf.secret) ||
            (!conf.key && conf.secret)) {
            return false;
        }
        return true;
    };
    // Defaults
    const accessKeyId = conf.key;
    const secretAccessKey = conf.secret;
    const region = conf.region;
    const bucket = conf.bucket ? conf.bucket : '';
    const sslEnabled = conf.sslEnabled === false ? false : true;
    const s3ForcePathStyle = conf.s3ForcePathStyle ? true : false;
    const cache = new nice_cache_1.default({
        verbose: !!conf.verbosity,
        refreshInterval: conf.refreshInterval
    });
    let requestHandler;
    if (conf.agentProxy) {
        const handlerOptions = {
            connectionTimeout: conf.timeout || 10000
        };
        if (sslEnabled) {
            handlerOptions.httpAgent = conf.agentProxy;
        }
        else {
            handlerOptions.httpsAgent = conf.agentProxy;
        }
        requestHandler = new node_http_handler_1.NodeHttpHandler(handlerOptions);
    }
    const getClient = () => new client_s3_1.S3({
        logger: conf.debug ? console.log : undefined,
        tls: sslEnabled,
        credentials: {
            accessKeyId: accessKeyId,
            secretAccessKey: secretAccessKey
        },
        requestHandler,
        endpoint: conf.endpoint,
        region,
        forcePathStyle: s3ForcePathStyle
    });
    const getFile = async (filePath, force = false) => {
        const getFromAws = async () => {
            try {
                const data = await getClient().getObject({
                    Bucket: bucket,
                    Key: filePath
                });
                return streamToString(data.Body);
            }
            catch (err) {
                throw err.code === 'NoSuchKey'
                    ? {
                        code: oc_storage_adapters_utils_1.strings.errors.STORAGE.FILE_NOT_FOUND_CODE,
                        msg: oc_storage_adapters_utils_1.strings.errors.STORAGE.FILE_NOT_FOUND(filePath)
                    }
                    : err;
            }
        };
        if (force) {
            return getFromAws();
        }
        const cached = cache.get('s3-file', filePath);
        if (cached) {
            return cached;
        }
        const result = await getFromAws();
        cache.set('s3-file', filePath, result);
        cache.sub('s3-file', filePath, getFromAws);
        return result;
    };
    const getJson = async (filePath, force = false) => {
        const file = await getFile(filePath, force);
        try {
            return JSON.parse(file);
        }
        catch (er) {
            throw {
                code: oc_storage_adapters_utils_1.strings.errors.STORAGE.FILE_NOT_VALID_CODE,
                msg: oc_storage_adapters_utils_1.strings.errors.STORAGE.FILE_NOT_VALID(filePath)
            };
        }
    };
    const getUrl = (componentName, version, fileName) => `${conf.path}${componentName}/${version}/${fileName}`;
    const listSubDirectories = async (dir) => {
        const normalisedPath = dir.lastIndexOf('/') === dir.length - 1 && dir.length > 0
            ? dir
            : `${dir}/`;
        const data = await getClient().listObjects({
            Bucket: bucket,
            Prefix: normalisedPath,
            Delimiter: '/'
        });
        if (data.CommonPrefixes.length === 0) {
            throw {
                code: oc_storage_adapters_utils_1.strings.errors.STORAGE.DIR_NOT_FOUND_CODE,
                msg: oc_storage_adapters_utils_1.strings.errors.STORAGE.DIR_NOT_FOUND(dir)
            };
        }
        const result = lodash_1.default.map(data.CommonPrefixes, commonPrefix => commonPrefix.Prefix.substr(normalisedPath.length, commonPrefix.Prefix.length - normalisedPath.length - 1));
        return result;
    };
    const putDir = async (dirInput, dirOutput) => {
        const paths = await getPaths(dirInput);
        const packageJsonFile = path_1.default.join(dirInput, 'package.json');
        const files = paths.files.filter(file => file !== packageJsonFile);
        const filesResults = await Promise.all(files.map((file) => {
            const relativeFile = file.slice(dirInput.length);
            const url = (dirOutput + relativeFile).replace(/\\/g, '/');
            const serverPattern = /(\\|\/)server\.js/;
            const dotFilePattern = /(\\|\/)\..+/;
            const privateFilePatterns = [serverPattern, dotFilePattern];
            return putFile(file, url, privateFilePatterns.some(r => r.test(relativeFile)));
        }));
        // Ensuring package.json is uploaded last so we can verify that a component
        // was properly uploaded by checking if package.json exists
        const packageJsonFileResult = await putFile(packageJsonFile, `${dirOutput}/package.json`.replace(/\\/g, '/'), false);
        return [...filesResults, packageJsonFileResult];
    };
    const putFileContent = async (fileContent, fileName, isPrivate) => {
        const fileInfo = (0, oc_storage_adapters_utils_1.getFileInfo)(fileName);
        return getClient().putObject({
            Bucket: bucket,
            Key: fileName,
            Body: fileContent,
            ContentType: fileInfo.mimeType,
            ContentEncoding: fileInfo.gzip ? 'gzip' : undefined,
            ACL: isPrivate ? 'authenticated-read' : 'public-read',
            ServerSideEncryption: 'AES256',
            Expires: (0, oc_storage_adapters_utils_1.getNextYear)()
        });
    };
    const putFile = (filePath, fileName, isPrivate) => {
        const stream = fs_extra_1.default.createReadStream(filePath);
        return putFileContent(stream, fileName, isPrivate);
    };
    return {
        getFile,
        getJson,
        getUrl,
        listSubDirectories,
        maxConcurrentRequests: 20,
        putDir,
        putFile,
        putFileContent,
        adapterType: 's3',
        isValid
    };
}
exports.default = s3Adapter;
module.exports = s3Adapter;
