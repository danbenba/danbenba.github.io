"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const semver_1 = __importDefault(require("semver"));
const p_limit_1 = __importDefault(require("p-limit"));
const oc_get_unix_utc_timestamp_1 = __importDefault(require("oc-get-unix-utc-timestamp"));
const events_handler_1 = __importDefault(require("../events-handler"));
function componentsList(conf, cdn) {
    const filePath = () => `${conf.storage.options.componentsDir}/components.json`;
    const componentsList = {
        getFromJson: () => cdn.getJson(filePath(), true),
        getFromDirectories: async (jsonList) => {
            const componentsInfo = {};
            const validateComponentVersion = (componentName, componentVersion) => {
                return cdn
                    .getJson(
                // Check integrity of the package by checking existence of package.json
                // OC will upload always the package.json last when publishing
                `${conf.storage.options.componentsDir}/${componentName}/${componentVersion}/package.json`)
                    .then(() => true)
                    .catch(() => false);
            };
            const getVersionsForComponent = async (componentName) => {
                const allVersions = await cdn.listSubDirectories(`${conf.storage.options.componentsDir}/${componentName}`);
                const unCheckedVersions = allVersions.filter(version => !jsonList?.components[componentName]?.includes(version));
                const limit = (0, p_limit_1.default)(cdn.maxConcurrentRequests);
                const invalidVersions = (await Promise.all(unCheckedVersions.map(unCheckedVersion => limit(async () => {
                    const isValid = await validateComponentVersion(componentName, unCheckedVersion);
                    return isValid ? null : unCheckedVersion;
                })))).filter((x) => typeof x === 'string');
                if (invalidVersions.length > 0) {
                    events_handler_1.default.fire('error', {
                        code: 'corrupted_version',
                        message: `Couldn't validate the integrity of the component ${componentName} on the following versions: ${invalidVersions.join(', ')}.`
                    });
                }
                const validVersions = allVersions.filter(version => !invalidVersions.includes(version));
                return validVersions.sort(semver_1.default.compare);
            };
            try {
                const components = await cdn.listSubDirectories(conf.storage.options.componentsDir);
                const limit = (0, p_limit_1.default)(cdn.maxConcurrentRequests);
                const versions = await Promise.all(components.map(component => limit(() => getVersionsForComponent(component))));
                components.forEach((component, i) => {
                    componentsInfo[component] = versions[i];
                });
                return {
                    lastEdit: (0, oc_get_unix_utc_timestamp_1.default)(),
                    components: componentsInfo
                };
            }
            catch (err) {
                if (err.code === 'dir_not_found') {
                    return {
                        lastEdit: (0, oc_get_unix_utc_timestamp_1.default)(),
                        components: {}
                    };
                }
                throw err;
            }
        },
        async refresh(cachedList) {
            const components = await componentsList.getFromDirectories(cachedList);
            await componentsList.save(components);
            return components;
        },
        save: (data) => cdn.putFileContent(JSON.stringify(data), filePath(), true)
    };
    return componentsList;
}
exports.default = componentsList;
