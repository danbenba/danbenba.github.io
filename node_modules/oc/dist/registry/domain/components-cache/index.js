"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const components_list_1 = __importDefault(require("./components-list"));
const events_handler_1 = __importDefault(require("../events-handler"));
const oc_get_unix_utc_timestamp_1 = __importDefault(require("oc-get-unix-utc-timestamp"));
const oc_storage_adapters_utils_1 = require("oc-storage-adapters-utils");
function componentsCache(conf, cdn) {
    let cachedComponentsList;
    let refreshLoop;
    const componentsList = (0, components_list_1.default)(conf, cdn);
    const poll = () => {
        return setTimeout(async () => {
            try {
                const data = await componentsList.getFromJson();
                events_handler_1.default.fire('cache-poll', (0, oc_get_unix_utc_timestamp_1.default)());
                if (data.lastEdit > cachedComponentsList.lastEdit) {
                    cachedComponentsList = data;
                }
            }
            catch (err) {
                events_handler_1.default.fire('error', {
                    code: 'components_list_get',
                    message: err?.message || String(err)
                });
            }
            refreshLoop = poll();
        }, conf.pollingInterval * 1000);
    };
    const cacheDataAndStartPolling = (data) => {
        cachedComponentsList = data;
        refreshLoop = poll();
        return data;
    };
    const throwError = (code, message) => {
        events_handler_1.default.fire('error', { code, message: message?.message ?? message });
        throw code;
    };
    return {
        get() {
            if (!cachedComponentsList) {
                return throwError('components_cache_empty', `The component's cache was empty`);
            }
            return cachedComponentsList;
        },
        async load() {
            const jsonComponents = await componentsList.getFromJson().catch(err => {
                if (err?.code === oc_storage_adapters_utils_1.strings.errors.STORAGE.FILE_NOT_FOUND_CODE)
                    return null;
                return Promise.reject(err);
            });
            const dirComponents = await componentsList
                .getFromDirectories(jsonComponents)
                .catch(err => throwError('components_list_get', err));
            if (!jsonComponents ||
                !lodash_1.default.isEqual(dirComponents.components, jsonComponents.components)) {
                await componentsList
                    .save(dirComponents)
                    .catch(err => throwError('components_list_save', err));
            }
            cacheDataAndStartPolling(dirComponents);
            return dirComponents;
        },
        async refresh() {
            clearTimeout(refreshLoop);
            try {
                // Passing components that we know are fine, so it doesn't refresh invalid components
                const components = await componentsList.refresh(cachedComponentsList);
                cacheDataAndStartPolling(components);
                return components;
            }
            catch (err) {
                return throwError('components_cache_refresh', err);
            }
        }
    };
}
exports.default = componentsCache;
