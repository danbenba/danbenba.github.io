"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const oc_get_unix_utc_timestamp_1 = __importDefault(require("oc-get-unix-utc-timestamp"));
const path_1 = __importDefault(require("path"));
const dotenv_1 = __importDefault(require("dotenv"));
const components_cache_1 = __importDefault(require("./components-cache"));
const components_details_1 = __importDefault(require("./components-details"));
const register_templates_1 = __importDefault(require("./register-templates"));
const settings_1 = __importDefault(require("../../resources/settings"));
const resources_1 = __importDefault(require("../../resources"));
const validator = __importStar(require("./validators"));
const storage_adapter_1 = __importDefault(require("./storage-adapter"));
const versionHandler = __importStar(require("./version-handler"));
const error_to_string_1 = __importDefault(require("../../utils/error-to-string"));
const packageInfo = fs_extra_1.default.readJsonSync(path_1.default.join(__dirname, '..', '..', '..', 'package.json'));
function repository(conf) {
    const cdn = !conf.local &&
        (0, storage_adapter_1.default)(conf.storage.adapter(conf.storage.options));
    const options = !conf.local ? conf.storage.options : null;
    const repositorySource = conf.local
        ? 'local repository'
        : cdn.adapterType + ' cdn';
    const componentsCache = (0, components_cache_1.default)(conf, cdn);
    const componentsDetails = (0, components_details_1.default)(conf, cdn);
    const getFilePath = (component, version, filePath) => `${options.componentsDir}/${component}/${version}/${filePath}`;
    const { templatesHash, templatesInfo } = (0, register_templates_1.default)(conf.templates, conf.local);
    const local = {
        getCompiledView(componentName) {
            if (componentName === 'oc-client') {
                return fs_extra_1.default
                    .readFileSync(path_1.default.join(__dirname, '../../components/oc-client/_package/template.js'))
                    .toString();
            }
            return fs_extra_1.default
                .readFileSync(path_1.default.join(conf.path, `${componentName}/_package/template.js`))
                .toString();
        },
        getComponents() {
            const validComponents = conf.components ||
                fs_extra_1.default.readdirSync(conf.path).filter(file => {
                    const isDir = fs_extra_1.default.lstatSync(path_1.default.join(conf.path, file)).isDirectory();
                    const isValidComponent = isDir
                        ? fs_extra_1.default
                            .readdirSync(path_1.default.join(conf.path, file))
                            .filter(file => file === '_package').length === 1
                        : false;
                    return isValidComponent;
                });
            validComponents.push('oc-client');
            return validComponents;
        },
        getComponentVersions(componentName) {
            if (componentName === 'oc-client') {
                return Promise.all([
                    fs_extra_1.default
                        .readJson(path_1.default.join(__dirname, '../../../package.json'))
                        .then(x => x.version)
                ]);
            }
            if (!local.getComponents().includes(componentName)) {
                return Promise.reject(resources_1.default.errors.registry.COMPONENT_NOT_FOUND(componentName, repositorySource));
            }
            return Promise.all([
                fs_extra_1.default
                    .readJson(path_1.default.join(conf.path, `${componentName}/package.json`))
                    .then(x => x.version)
            ]);
        },
        getDataProvider(componentName) {
            const ocClientServerPath = '../../components/oc-client/_package/server.js';
            const filePath = componentName === 'oc-client'
                ? path_1.default.join(__dirname, ocClientServerPath)
                : path_1.default.join(conf.path, `${componentName}/_package/server.js`);
            return {
                content: fs_extra_1.default.readFileSync(filePath).toString(),
                filePath
            };
        },
        getEnv(componentName) {
            const pkg = fs_extra_1.default.readJsonSync(path_1.default.join(conf.path, `${componentName}/package.json`));
            const filePath = path_1.default.join(conf.path, componentName, pkg.oc.files.env);
            return dotenv_1.default.parse(fs_extra_1.default.readFileSync(filePath).toString());
        }
    };
    const repository = {
        getCompiledView(componentName, componentVersion) {
            if (conf.local) {
                return Promise.resolve(local.getCompiledView(componentName));
            }
            return cdn.getFile(getFilePath(componentName, componentVersion, 'template.js'));
        },
        async getComponent(componentName, componentVersion) {
            const allVersions = await repository.getComponentVersions(componentName);
            if (allVersions.length === 0) {
                throw resources_1.default.errors.registry.COMPONENT_NOT_FOUND(componentName, repositorySource);
            }
            const version = versionHandler.getAvailableVersion(componentVersion, allVersions);
            if (!version) {
                throw resources_1.default.errors.registry.COMPONENT_VERSION_NOT_FOUND(componentName, componentVersion || '', repositorySource);
            }
            const component = await repository
                .getComponentInfo(componentName, version)
                .catch(err => {
                throw `component not available: ${(0, error_to_string_1.default)(err)}`;
            });
            return Object.assign(component, { allVersions });
        },
        getComponentInfo(componentName, componentVersion) {
            if (conf.local) {
                let componentInfo;
                if (componentName === 'oc-client') {
                    componentInfo = fs_extra_1.default.readJsonSync(path_1.default.join(__dirname, '../../components/oc-client/_package/package.json'));
                }
                else {
                    componentInfo = fs_extra_1.default.readJsonSync(path_1.default.join(conf.path, `${componentName}/_package/package.json`));
                }
                if (componentInfo.version === componentVersion) {
                    return Promise.resolve(componentInfo);
                }
                else {
                    // eslint-disable-next-line prefer-promise-reject-errors
                    return Promise.reject('version not available');
                }
            }
            return cdn.getJson(getFilePath(componentName, componentVersion, 'package.json'), false);
        },
        getComponentPath(componentName, componentVersion) {
            const prefix = conf.local
                ? conf.baseUrl
                : `${options['path']}${options.componentsDir}/`;
            return `${prefix}${componentName}/${componentVersion}/`;
        },
        async getComponents() {
            if (conf.local) {
                return local.getComponents();
            }
            const { components } = await componentsCache.get();
            return Object.keys(components);
        },
        getComponentsDetails() {
            if (conf.local) {
                // when in local this won't get called
                return Promise.resolve(null);
            }
            return componentsDetails.get();
        },
        async getComponentVersions(componentName) {
            if (conf.local) {
                return local.getComponentVersions(componentName);
            }
            const res = await componentsCache.get();
            return res.components[componentName] ? res.components[componentName] : [];
        },
        async getDataProvider(componentName, componentVersion) {
            if (conf.local) {
                return local.getDataProvider(componentName);
            }
            const filePath = getFilePath(componentName, componentVersion, 'server.js');
            const content = await cdn.getFile(filePath);
            return { content, filePath };
        },
        async getEnv(componentName, componentVersion) {
            if (conf.local) {
                return local.getEnv(componentName);
            }
            const filePath = getFilePath(componentName, componentVersion, '.env');
            const file = await cdn.getFile(filePath);
            return dotenv_1.default.parse(file);
        },
        getStaticClientPath: () => `${options['path']}${getFilePath('oc-client', packageInfo.version, 'src/oc-client.min.js')}`,
        getStaticClientMapPath: () => `${options['path']}${getFilePath('oc-client', packageInfo.version, 'src/oc-client.min.map')}`,
        getStaticFilePath: (componentName, componentVersion, filePath) => `${repository.getComponentPath(componentName, componentVersion)}${conf.local ? settings_1.default.registry.localStaticRedirectorPath : ''}${filePath}`,
        getTemplatesInfo: () => templatesInfo,
        getTemplate: (type) => templatesHash[type],
        async init() {
            if (conf.local) {
                // when in local this won't get called
                return;
            }
            const componentsList = await componentsCache.load();
            return componentsDetails.refresh(componentsList);
        },
        async publishComponent(pkgDetails, componentName, componentVersion) {
            if (conf.local) {
                throw {
                    code: resources_1.default.errors.registry.LOCAL_PUBLISH_NOT_ALLOWED_CODE,
                    msg: resources_1.default.errors.registry.LOCAL_PUBLISH_NOT_ALLOWED
                };
            }
            if (!validator.validateComponentName(componentName)) {
                throw {
                    code: resources_1.default.errors.registry.COMPONENT_NAME_NOT_VALID_CODE,
                    msg: resources_1.default.errors.registry.COMPONENT_NAME_NOT_VALID
                };
            }
            if (!validator.validateVersion(componentVersion)) {
                throw {
                    code: resources_1.default.errors.registry.COMPONENT_VERSION_NOT_VALID_CODE,
                    msg: resources_1.default.errors.registry.COMPONENT_VERSION_NOT_VALID(componentVersion)
                };
            }
            const validationResult = validator.validatePackageJson(Object.assign(pkgDetails, {
                componentName,
                customValidator: conf.publishValidation
            }));
            if (!validationResult.isValid) {
                throw {
                    code: resources_1.default.errors.registry.COMPONENT_PUBLISHVALIDATION_FAIL_CODE,
                    msg: resources_1.default.errors.registry.COMPONENT_PUBLISHVALIDATION_FAIL(String(validationResult.error))
                };
            }
            const componentVersions = await repository.getComponentVersions(componentName);
            if (!versionHandler.validateNewVersion(componentVersion, componentVersions)) {
                throw {
                    code: resources_1.default.errors.registry.COMPONENT_VERSION_ALREADY_FOUND_CODE,
                    msg: resources_1.default.errors.registry.COMPONENT_VERSION_ALREADY_FOUND(componentName, componentVersion, repositorySource)
                };
            }
            pkgDetails.packageJson.oc.date = (0, oc_get_unix_utc_timestamp_1.default)();
            await fs_extra_1.default.writeJson(path_1.default.join(pkgDetails.outputFolder, 'package.json'), pkgDetails.packageJson);
            await cdn.putDir(pkgDetails.outputFolder, `${options.componentsDir}/${componentName}/${componentVersion}`);
            const componentsList = await componentsCache.refresh();
            return componentsDetails.refresh(componentsList);
        }
    };
    return repository;
}
exports.default = repository;
