"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.init = void 0;
const p_limit_1 = __importDefault(require("p-limit"));
const lodash_1 = __importDefault(require("lodash"));
const dependency_graph_1 = require("dependency-graph");
const util_1 = require("util");
const resources_1 = __importDefault(require("../../resources"));
function validatePlugins(plugins) {
    for (let idx = 0; idx < plugins.length; idx++) {
        const plugin = plugins[idx];
        if (!lodash_1.default.isObject(plugin.register) ||
            typeof plugin.register.register !== 'function' ||
            typeof plugin.register.execute !== 'function' ||
            typeof plugin.name !== 'string') {
            throw new Error(resources_1.default.errors.registry.PLUGIN_NOT_VALID(plugin.name || String(idx + 1)));
        }
    }
}
function checkDependencies(plugins) {
    const graph = new dependency_graph_1.DepGraph();
    plugins.forEach(p => graph.addNode(p.name));
    plugins.forEach(p => {
        if (!p.register.dependencies) {
            return;
        }
        p.register.dependencies.forEach(d => {
            try {
                graph.addDependency(p.name, d);
            }
            catch (err) {
                throw new Error(`unknown plugin dependency: ${d}`);
            }
        });
    });
    return graph.overallOrder();
}
let deferredLoads = [];
async function init(pluginsToRegister) {
    const registered = {};
    validatePlugins(pluginsToRegister);
    checkDependencies(pluginsToRegister);
    const dependenciesRegistered = (dependencies) => {
        if (dependencies.length === 0) {
            return true;
        }
        let present = true;
        dependencies.forEach(d => {
            if (!registered[d]) {
                present = false;
            }
        });
        return present;
    };
    const loadPlugin = async (plugin) => {
        if (registered[plugin.name]) {
            return;
        }
        if (!plugin.register.dependencies) {
            plugin.register.dependencies = [];
        }
        if (!dependenciesRegistered(plugin.register.dependencies)) {
            deferredLoads.push(plugin);
            return;
        }
        const dependencies = lodash_1.default.pick(registered, plugin.register.dependencies);
        const register = (0, util_1.promisify)(plugin.register.register);
        const pluginCallback = plugin.callback || lodash_1.default.noop;
        await register(plugin.options || {}, dependencies).catch(err => {
            pluginCallback(err);
            throw err;
        });
        // Overriding toString so implementation details of plugins do not
        // leak to OC consumers
        plugin.register.execute.toString = () => plugin.description || '';
        registered[plugin.name] = plugin.register.execute;
        pluginCallback();
    };
    const terminator = async () => {
        if (deferredLoads.length > 0) {
            const deferredPlugins = lodash_1.default.clone(deferredLoads);
            deferredLoads = [];
            await Promise.all(deferredPlugins.map(plugin => onSeries(() => loadPlugin(plugin))));
            return terminator();
        }
        return registered;
    };
    const onSeries = (0, p_limit_1.default)(1);
    await Promise.all(pluginsToRegister.map(plugin => onSeries(() => loadPlugin(plugin))));
    return terminator();
}
exports.init = init;
