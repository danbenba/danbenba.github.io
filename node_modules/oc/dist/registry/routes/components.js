"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const async_1 = __importDefault(require("async"));
const lodash_1 = __importDefault(require("lodash"));
const get_component_1 = __importDefault(require("./helpers/get-component"));
const resources_1 = __importDefault(require("../../resources"));
function components(conf, repository) {
    const getComponent = (0, get_component_1.default)(conf, repository);
    const setHeaders = (results, res) => {
        if (!results || results.length !== 1 || !results[0] || !res.set) {
            return;
        }
        res.set(results[0].headers);
    };
    return (req, res) => {
        const components = req.body.components;
        const registryErrors = resources_1.default.errors.registry;
        const returnError = function (message) {
            res.status(400).json({
                code: registryErrors.BATCH_ROUTE_BODY_NOT_VALID_CODE,
                error: registryErrors.BATCH_ROUTE_BODY_NOT_VALID(message)
            });
        };
        if (!components) {
            return returnError(registryErrors.BATCH_ROUTE_COMPONENTS_PROPERTY_MISSING);
        }
        else if (!Array.isArray(components)) {
            return returnError(registryErrors.BATCH_ROUTE_COMPONENTS_NOT_ARRAY);
        }
        if (!lodash_1.default.isEmpty(components)) {
            const errors = lodash_1.default.compact(components.map((component, index) => {
                return !component.name
                    ? registryErrors.BATCH_ROUTE_COMPONENT_NAME_MISSING(index)
                    : '';
            }));
            if (!lodash_1.default.isEmpty(errors)) {
                return returnError(errors.join(', '));
            }
        }
        async_1.default.map(components, (component, callback) => {
            getComponent({
                conf: res.conf,
                name: component.name,
                headers: req.headers,
                ip: req.ip,
                omitHref: !!req.body.omitHref,
                parameters: { ...req.body.parameters, ...component.parameters },
                version: component.version
            }, result => callback(null, result));
        }, 
        // @ts-ignore
        (err, results) => {
            try {
                setHeaders(results, res);
                res.status(200).json(results);
            }
            catch (e) {
                // @ts-ignore I think this will never reach (how can setHeaders throw?)
                if (results.code && results.error) {
                    // @ts-ignore
                    res.status(500).json({ code: results.code, error: results.error });
                }
                else {
                    res.status(500).json({
                        code: 'RENDER_ERROR',
                        error: resources_1.default.errors.registry.RENDER_ERROR(results
                            .map(x => `${x.response.name}@${x.response.version}`)
                            .join(', '), String(e))
                    });
                }
            }
        });
    };
}
exports.default = components;
