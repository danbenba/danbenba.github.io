"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const accept_language_parser_1 = __importDefault(require("accept-language-parser"));
const nice_cache_1 = __importDefault(require("nice-cache"));
const oc_client_1 = __importDefault(require("oc-client"));
const domain_1 = __importDefault(require("domain"));
const oc_empty_response_handler_1 = __importDefault(require("oc-empty-response-handler"));
const vm_1 = __importDefault(require("vm"));
const lodash_1 = __importDefault(require("lodash"));
const apply_default_values_1 = __importDefault(require("./apply-default-values"));
const events_handler_1 = __importDefault(require("../../domain/events-handler"));
const get_component_retrieving_info_1 = __importDefault(require("./get-component-retrieving-info"));
const getComponentFallback = __importStar(require("./get-component-fallback"));
const is_template_legacy_1 = __importDefault(require("../../../utils/is-template-legacy"));
const nested_renderer_1 = __importDefault(require("../../domain/nested-renderer"));
const require_wrapper_1 = __importDefault(require("../../domain/require-wrapper"));
const sanitiser = __importStar(require("../../domain/sanitiser"));
const settings_1 = __importDefault(require("../../../resources/settings"));
const resources_1 = __importDefault(require("../../../resources"));
const urlBuilder = __importStar(require("../../domain/url-builder"));
const validator = __importStar(require("../../domain/validators"));
const universalify_1 = require("universalify");
const noopConsole = Object.fromEntries(Object.keys(console).map(key => [key, lodash_1.default.noop]));
function getComponent(conf, repository) {
    const client = (0, oc_client_1.default)({ templates: conf.templates });
    const cache = new nice_cache_1.default({
        verbose: !!conf.verbosity,
        refreshInterval: conf.refreshInterval
    });
    const getEnv = async (component) => {
        const cacheKey = `${component.name}/${component.version}/.env`;
        const cached = cache.get('file-contents', cacheKey);
        if (cached)
            return cached;
        const env = component.oc.files.env
            ? await repository.getEnv(component.name, component.version)
            : {};
        cache.set('file-contents', cacheKey, env);
        return env;
    };
    const renderer = function (options, cb) {
        const nestedRenderer = (0, nested_renderer_1.default)(renderer, options.conf);
        const retrievingInfo = (0, get_component_retrieving_info_1.default)(options);
        let responseHeaders = {};
        const getLanguage = () => {
            const paramOverride = !!options.parameters && options.parameters['__ocAcceptLanguage'];
            return paramOverride || options.headers['accept-language'];
        };
        const callback = (result) => {
            if (result.response.error) {
                retrievingInfo.extend(result.response);
            }
            retrievingInfo.extend({ status: result.status });
            Object.assign(result.response, {
                name: options.name,
                requestVersion: options.version || ''
            });
            events_handler_1.default.fire('component-retrieved', retrievingInfo.getData());
            return cb(result);
        };
        let componentCallbackDone = false;
        const conf = options.conf;
        const acceptLanguage = getLanguage();
        const requestedComponent = {
            name: options.name,
            version: options.version || '',
            parameters: options.parameters
        };
        (0, universalify_1.fromPromise)(repository.getComponent)(requestedComponent.name, requestedComponent.version, (err, component) => {
            // check route exist for component and version
            if (err) {
                if (conf.fallbackRegistryUrl) {
                    return getComponentFallback.getComponent(conf.fallbackRegistryUrl, options.headers, requestedComponent, callback);
                }
                return callback({
                    status: 404,
                    response: {
                        code: 'NOT_FOUND',
                        error: err
                    }
                });
            }
            // Skip rendering and return only the component info in case of 'accept: application/vnd.oc.info+json'
            if (options.headers.accept === settings_1.default.registry.acceptInfoHeader) {
                return callback({
                    status: 200,
                    response: {
                        type: conf.local ? 'oc-component-local' : 'oc-component',
                        version: component.version,
                        requestVersion: requestedComponent.version,
                        name: requestedComponent.name
                    }
                });
            }
            // check component requirements are satisfied by registry
            const pluginsCompatibility = validator.validatePluginsRequirements(component.oc.plugins, conf.plugins);
            if (!pluginsCompatibility.isValid) {
                return callback({
                    status: 501,
                    response: {
                        code: 'PLUGIN_MISSING_FROM_REGISTRY',
                        error: resources_1.default.errors.registry.PLUGIN_NOT_IMPLEMENTED(pluginsCompatibility.missing.join(', ')),
                        missingPlugins: pluginsCompatibility.missing
                    }
                });
            }
            // sanitise and check params
            const appliedParams = (0, apply_default_values_1.default)(requestedComponent.parameters, component.oc.parameters);
            const params = sanitiser.sanitiseComponentParameters(appliedParams, component.oc.parameters);
            const validationResult = validator.validateComponentParameters(
            // @ts-ignore
            params, component.oc.parameters);
            if (!validationResult.isValid) {
                return callback({
                    status: 400,
                    response: {
                        code: 'NOT_VALID_REQUEST',
                        error: validationResult.errors.message
                    }
                });
            }
            // Support legacy templates
            let templateType = component.oc.files.template.type;
            const isLegacyTemplate = (0, is_template_legacy_1.default)(templateType);
            if (isLegacyTemplate) {
                templateType = `oc-template-${templateType}`;
            }
            if (!repository.getTemplate(templateType)) {
                return callback({
                    status: 400,
                    response: {
                        code: 'TEMPLATE_NOT_SUPPORTED',
                        error: resources_1.default.errors.registry.TEMPLATE_NOT_SUPPORTED(templateType)
                    }
                });
            }
            const filterCustomHeaders = (headers, requestedVersion, actualVersion) => {
                const needFiltering = !lodash_1.default.isEmpty(headers) &&
                    !lodash_1.default.isEmpty(conf.customHeadersToSkipOnWeakVersion) &&
                    requestedVersion !== actualVersion;
                return needFiltering
                    ? lodash_1.default.omit(headers, conf.customHeadersToSkipOnWeakVersion)
                    : headers;
            };
            const returnComponent = (err, data) => {
                if (componentCallbackDone) {
                    return;
                }
                componentCallbackDone = true;
                const componentHref = urlBuilder.component({
                    name: component.name,
                    version: requestedComponent.version,
                    // @ts-ignore
                    parameters: params
                }, conf.baseUrl);
                const isUnrendered = options.headers.accept === settings_1.default.registry.acceptUnrenderedHeader;
                const isValidClientRequest = options.headers['user-agent'] &&
                    !!options.headers['user-agent'].match('oc-client-');
                const parseTemplatesHeader = (t) => t.split(';').map(t => t.split(',')[0]);
                const supportedTemplates = options.headers['templates']
                    ? parseTemplatesHeader(options.headers['templates'])
                    : [];
                const isTemplateSupportedByClient = Boolean(isValidClientRequest &&
                    options.headers['templates'] &&
                    (lodash_1.default.includes(supportedTemplates, component.oc.files.template.type) ||
                        lodash_1.default.includes(supportedTemplates, templateType)));
                let renderMode = 'rendered';
                if (isUnrendered) {
                    renderMode = 'unrendered';
                    if (isValidClientRequest &&
                        !isTemplateSupportedByClient &&
                        !isLegacyTemplate) {
                        renderMode = 'rendered';
                    }
                }
                retrievingInfo.extend({
                    href: componentHref,
                    version: component.version,
                    renderMode
                });
                if (!!err || !data) {
                    err =
                        err ||
                            new Error(resources_1.default.errors.registry.DATA_OBJECT_IS_UNDEFINED);
                    const status = Number(err.status) || 500;
                    events_handler_1.default.fire('data-provider-error', {
                        status,
                        name: component.name,
                        requestVersion: requestedComponent.version,
                        parameters: params,
                        version: component.version,
                        error: err
                    });
                    return callback({
                        status,
                        response: {
                            code: 'GENERIC_ERROR',
                            error: resources_1.default.errors.registry.COMPONENT_EXECUTION_ERROR(err.message || ''),
                            details: {
                                message: err.message,
                                stack: err.stack,
                                originalError: err
                            }
                        }
                    });
                }
                const response = {
                    type: conf.local ? 'oc-component-local' : 'oc-component',
                    version: component.version,
                    requestVersion: requestedComponent.version,
                    name: requestedComponent.name,
                    renderMode
                };
                if (!options.omitHref) {
                    response.href = componentHref;
                }
                responseHeaders = filterCustomHeaders(responseHeaders, requestedComponent.version, component.version);
                if (renderMode === 'unrendered') {
                    callback({
                        status: 200,
                        headers: responseHeaders,
                        response: Object.assign(response, {
                            data: data,
                            template: {
                                src: repository.getStaticFilePath(component.name, component.version, 'template.js'),
                                type: component.oc.files.template.type,
                                key: component.oc.files.template.hashKey
                            }
                        })
                    });
                }
                else {
                    const cacheKey = `${component.name}/${component.version}/template.js`;
                    const cached = cache.get('file-contents', cacheKey);
                    const key = component.oc.files.template.hashKey;
                    const renderOptions = {
                        href: componentHref,
                        key,
                        version: component.version,
                        name: component.name,
                        templateType: component.oc.files.template.type,
                        container: component.oc.container,
                        renderInfo: component.oc.renderInfo
                    };
                    const returnResult = (template) => {
                        client.renderTemplate(template, data, renderOptions, (err, html) => {
                            if (err) {
                                return callback({
                                    status: 500,
                                    response: {
                                        code: 'INTERNAL_SERVER_ERROR',
                                        error: err
                                    }
                                });
                            }
                            callback({
                                status: 200,
                                headers: responseHeaders,
                                response: Object.assign(response, { html })
                            });
                        });
                    };
                    if (!!cached && !conf.hotReloading) {
                        returnResult(cached);
                    }
                    else {
                        (0, universalify_1.fromPromise)(repository.getCompiledView)(component.name, component.version, (_err, templateText) => {
                            let ocTemplate;
                            try {
                                ocTemplate = repository.getTemplate(templateType);
                            }
                            catch (err) {
                                return callback({
                                    status: 400,
                                    response: {
                                        code: 'TEMPLATE_NOT_SUPPORTED',
                                        error: resources_1.default.errors.registry.TEMPLATE_NOT_SUPPORTED(templateType)
                                    }
                                });
                            }
                            const template = ocTemplate.getCompiledTemplate(templateText, key);
                            cache.set('file-contents', cacheKey, template);
                            returnResult(template);
                        });
                    }
                }
            };
            if (!component.oc.files.dataProvider) {
                returnComponent(null, {});
            }
            else {
                (0, universalify_1.fromPromise)(getEnv)(component, (err, env) => {
                    if (err) {
                        componentCallbackDone = true;
                        return callback({
                            status: 502,
                            response: {
                                code: 'ENV_RESOLVING_ERROR',
                                error: resources_1.default.errors.registry.RESOLVING_ERROR
                            }
                        });
                    }
                    const cacheKey = `${component.name}/${component.version}/server.js`;
                    const cached = cache.get('file-contents', cacheKey);
                    const domain = domain_1.default.create();
                    const setEmptyResponse = oc_empty_response_handler_1.default.contextDecorator(returnComponent);
                    const contextObj = {
                        acceptLanguage: accept_language_parser_1.default.parse(acceptLanguage),
                        baseUrl: conf.baseUrl,
                        env: { ...conf.env, ...env },
                        params,
                        plugins: conf.plugins,
                        renderComponent: (0, universalify_1.fromPromise)(nestedRenderer.renderComponent),
                        renderComponents: (0, universalify_1.fromPromise)(nestedRenderer.renderComponents),
                        requestHeaders: options.headers,
                        requestIp: options.ip,
                        setEmptyResponse,
                        staticPath: repository
                            .getStaticFilePath(component.name, component.version, '')
                            .replace('https:', ''),
                        setHeader: (header, value) => {
                            if (!(typeof header === 'string' && typeof value === 'string')) {
                                throw resources_1.default.errors.registry
                                    .COMPONENT_SET_HEADER_PARAMETERS_NOT_VALID;
                            }
                            if (header && value) {
                                responseHeaders = responseHeaders || {};
                                responseHeaders[header.toLowerCase()] = value;
                            }
                        },
                        templates: repository.getTemplatesInfo()
                    };
                    const setCallbackTimeout = () => {
                        const executionTimeout = conf.executionTimeout;
                        if (executionTimeout) {
                            setTimeout(() => {
                                const message = `timeout (${executionTimeout * 1000}ms)`;
                                returnComponent({ message }, undefined);
                                domain.exit();
                            }, executionTimeout * 1000);
                        }
                    };
                    if (!!cached && !conf.hotReloading) {
                        domain.on('error', returnComponent);
                        try {
                            domain.run(() => {
                                cached(contextObj, returnComponent);
                                setCallbackTimeout();
                            });
                        }
                        catch (e) {
                            return returnComponent(e, undefined);
                        }
                    }
                    else {
                        (0, universalify_1.fromPromise)(repository.getDataProvider)(component.name, component.version, (err, dataProvider) => {
                            if (err) {
                                componentCallbackDone = true;
                                return callback({
                                    status: 502,
                                    response: {
                                        code: 'DATA_RESOLVING_ERROR',
                                        error: resources_1.default.errors.registry.RESOLVING_ERROR
                                    }
                                });
                            }
                            const context = {
                                require: (0, require_wrapper_1.default)(conf.dependencies),
                                module: {
                                    exports: {}
                                },
                                exports: {},
                                console: conf.local ? console : noopConsole,
                                setTimeout,
                                Buffer,
                                fetch: globalThis?.fetch
                            };
                            const handleError = (err) => {
                                if (err.code === 'DEPENDENCY_MISSING_FROM_REGISTRY') {
                                    componentCallbackDone = true;
                                    return callback({
                                        status: 501,
                                        response: {
                                            code: err.code,
                                            error: resources_1.default.errors.registry.DEPENDENCY_NOT_FOUND(err.missing.join(', ')),
                                            missingDependencies: err.missing
                                        }
                                    });
                                }
                                returnComponent(err, undefined);
                            };
                            const options = conf.local
                                ? {
                                    displayErrors: true,
                                    filename: dataProvider.filePath
                                }
                                : {};
                            try {
                                vm_1.default.runInNewContext(dataProvider.content, context, options);
                                const processData = context.module.exports['data'] || context.exports['data'];
                                cache.set('file-contents', cacheKey, processData);
                                domain.on('error', handleError);
                                domain.run(() => {
                                    processData(contextObj, returnComponent);
                                    setCallbackTimeout();
                                });
                            }
                            catch (err) {
                                handleError(err);
                            }
                        });
                    }
                });
            }
        });
    };
    return renderer;
}
exports.default = getComponent;
