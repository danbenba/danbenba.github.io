"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const async_1 = __importDefault(require("async"));
const parse_author_1 = __importDefault(require("parse-author"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const date_stringify_1 = __importDefault(require("../../utils/date-stringify"));
const get_components_history_1 = __importDefault(require("./helpers/get-components-history"));
const get_available_dependencies_1 = __importDefault(require("./helpers/get-available-dependencies"));
const views_1 = __importDefault(require("../views"));
const urlBuilder = require("../domain/url-builder");
const universalify_1 = require("universalify");
const packageInfo = fs_extra_1.default.readJsonSync(path_1.default.join(__dirname, '..', '..', '..', 'package.json'));
const getParsedAuthor = (author) => {
    author = author || {};
    return typeof author === 'string' ? (0, parse_author_1.default)(author) : author;
};
const mapComponentDetails = (component) => Object.assign(component, { author: getParsedAuthor(component.author) });
const isHtmlRequest = (headers) => !!headers.accept && headers.accept.indexOf('text/html') >= 0;
function default_1(repository) {
    return (req, res, next) => {
        (0, universalify_1.fromPromise)(repository.getComponents)((err, components) => {
            if (err) {
                res.errorDetails = 'cdn not available';
                res.status(404).json({ error: res.errorDetails });
                return;
            }
            const baseResponse = {
                href: res.conf.baseUrl,
                ocVersion: packageInfo.version,
                type: res.conf.local ? 'oc-registry-local' : 'oc-registry'
            };
            if (isHtmlRequest(req.headers) && !!res.conf.discovery) {
                let componentsInfo = [];
                let componentsReleases = 0;
                const stateCounts = {};
                async_1.default.each(components, (component, callback) => (0, universalify_1.fromPromise)(repository.getComponent)(component, undefined, (err, result) => {
                    if (err)
                        return callback(err);
                    if (result.oc && result.oc.date) {
                        result.oc.stringifiedDate = (0, date_stringify_1.default)(new Date(result.oc.date));
                    }
                    componentsInfo.push(mapComponentDetails(result));
                    componentsReleases += result.allVersions.length;
                    callback();
                }), err => {
                    if (err)
                        return next(err);
                    componentsInfo = lodash_1.default.sortBy(componentsInfo, 'name');
                    (0, universalify_1.fromPromise)(repository.getComponentsDetails)((err, details) => {
                        // eslint-disable-next-line no-console
                        if (err)
                            console.log(err);
                        res.send((0, views_1.default)(
                        // @ts-ignore
                        Object.assign(baseResponse, {
                            availableDependencies: (0, get_available_dependencies_1.default)(res.conf.dependencies),
                            availablePlugins: res.conf.plugins,
                            components: componentsInfo,
                            componentsReleases,
                            componentsList: componentsInfo.map(component => {
                                const state = lodash_1.default.get(component, 'oc.state', '');
                                if (state) {
                                    stateCounts[state] = (stateCounts[state] || 0) + 1;
                                }
                                return {
                                    name: component.name,
                                    author: component.author,
                                    state
                                };
                            }),
                            componentsHistory: !res.conf.local && (0, get_components_history_1.default)(details),
                            q: req.query['q'] || '',
                            stateCounts,
                            templates: repository.getTemplatesInfo(),
                            title: 'OpenComponents Registry'
                        })));
                    });
                });
            }
            else {
                res.status(200).json(Object.assign(baseResponse, {
                    components: lodash_1.default.map(components, component => urlBuilder.component(component, res.conf.baseUrl))
                }));
            }
        });
    };
}
exports.default = default_1;
