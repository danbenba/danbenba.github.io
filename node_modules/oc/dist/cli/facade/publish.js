"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const safe_1 = __importDefault(require("colors/safe"));
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const read_1 = __importDefault(require("read"));
const util_1 = require("util");
const universalify_1 = require("universalify");
const handle_dependencies_1 = __importDefault(require("../domain/handle-dependencies"));
const index_1 = __importDefault(require("../../resources/index"));
const read = (0, util_1.promisify)(read_1.default);
const publish = ({ logger, registry, local }) => (0, universalify_1.fromPromise)(async (opts) => {
    const componentPath = opts.componentPath;
    const skipPackage = opts.skipPackage;
    const packageDir = path_1.default.resolve(componentPath, '_package');
    const compressedPackagePath = path_1.default.resolve(componentPath, 'package.tar.gz');
    let errorMessage;
    const readPackageJson = () => fs_extra_1.default.readJson(path_1.default.join(packageDir, 'package.json'));
    const getCredentials = async () => {
        if (opts.username && opts.password) {
            logger.ok(index_1.default.messages.cli.USING_CREDS);
            const { username, password } = opts;
            return { username, password };
        }
        logger.warn(index_1.default.messages.cli.ENTER_USERNAME);
        const username = await read({});
        logger.warn(index_1.default.messages.cli.ENTER_PASSWORD);
        const password = await read({ silent: true });
        return { username, password };
    };
    const compress = () => local.compress(packageDir, compressedPackagePath);
    const packageAndCompress = async () => {
        logger.warn(index_1.default.messages.cli.PACKAGING(packageDir));
        const packageOptions = {
            production: true,
            componentPath: path_1.default.resolve(componentPath)
        };
        const component = await local.package(packageOptions);
        logger.warn(index_1.default.messages.cli.COMPRESSING(compressedPackagePath));
        await compress();
        return component;
    };
    const putComponentToRegistry = async (options) => {
        logger.warn(index_1.default.messages.cli.PUBLISHING(options.route));
        try {
            await registry.putComponent(options);
            logger.ok(index_1.default.messages.cli.PUBLISHED(options.route));
        }
        catch (err) {
            if (err === 'Unauthorized' || err.message === 'Unauthorized') {
                if (!!options.username || !!options.password) {
                    logger.err(index_1.default.errors.cli.PUBLISHING_FAIL(index_1.default.errors.cli.INVALID_CREDENTIALS));
                    throw err;
                }
                logger.warn(index_1.default.messages.cli.REGISTRY_CREDENTIALS_REQUIRED);
                const credentials = await getCredentials();
                await putComponentToRegistry(Object.assign(options, credentials));
            }
            else if (err.code === 'cli_version_not_valid') {
                const upgradeCommand = index_1.default.commands.cli.UPGRADE(err.details.suggestedVersion);
                const errorDetails = index_1.default.errors.cli.OC_CLI_VERSION_NEEDS_UPGRADE(safe_1.default.blue(upgradeCommand));
                errorMessage = index_1.default.errors.cli.PUBLISHING_FAIL(errorDetails);
                logger.err(errorMessage);
                throw errorMessage;
            }
            else if (err.code === 'node_version_not_valid') {
                const details = index_1.default.errors.cli.NODE_CLI_VERSION_NEEDS_UPGRADE(err.details.suggestedVersion);
                errorMessage = index_1.default.errors.cli.PUBLISHING_FAIL(details);
                logger.err(errorMessage);
                throw errorMessage;
            }
            else {
                if (err.message) {
                    // eslint-disable-next-line no-ex-assign
                    err = err.message;
                }
                else if (err && typeof err === 'object') {
                    try {
                        // eslint-disable-next-line no-ex-assign
                        err = JSON.stringify(err);
                    }
                    catch (er) { }
                }
                errorMessage = index_1.default.errors.cli.PUBLISHING_FAIL(String(err));
                logger.err(errorMessage);
                throw errorMessage;
            }
        }
    };
    const publishToRegistries = async (registryLocations, component) => {
        for (const registryUrl of registryLocations) {
            const registryNormalised = registryUrl.replace(/\/$/, '');
            const componentRoute = `${registryNormalised}/${component.name}/${component.version}`;
            await putComponentToRegistry({
                route: componentRoute,
                path: compressedPackagePath
            });
        }
        await local.cleanup(compressedPackagePath);
    };
    try {
        const registryLocations = opts.registries || (await registry.get());
        if (!skipPackage) {
            await (0, handle_dependencies_1.default)({
                components: [path_1.default.resolve(componentPath)],
                logger
            }).catch(err => {
                logger.err(err);
                return Promise.reject(err);
            });
            const component = await packageAndCompress().catch(err => {
                errorMessage = index_1.default.errors.cli.PACKAGE_CREATION_FAIL(String(err));
                logger.err(errorMessage);
                return Promise.reject(errorMessage);
            });
            await publishToRegistries(registryLocations, component);
        }
        else {
            if (fs_extra_1.default.existsSync(packageDir)) {
                const component = await readPackageJson().catch(err => {
                    logger.err(String(err));
                    return Promise.reject(err);
                });
                await compress().catch(err => {
                    logger.err(String(err));
                    return Promise.reject(err);
                });
                await publishToRegistries(registryLocations, component);
            }
            else {
                errorMessage = index_1.default.errors.cli.PACKAGE_FOLDER_MISSING;
                logger.err(errorMessage);
                throw errorMessage;
            }
        }
    }
    catch (err) {
        logger.err(String(err));
        throw err;
    }
});
exports.default = publish;
