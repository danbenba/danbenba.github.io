"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const got_1 = __importDefault(require("got"));
const lodash_1 = __importDefault(require("lodash"));
const put_1 = __importDefault(require("../../utils/put"));
const settings_1 = __importDefault(require("../../resources/settings"));
const urlBuilder = __importStar(require("../../registry/domain/url-builder"));
const urlParser = __importStar(require("../domain/url-parser"));
const getOcVersion = () => {
    const ocPackagePath = path_1.default.join(__dirname, '../../../package.json');
    const ocInfo = fs_extra_1.default.readJsonSync(ocPackagePath);
    return ocInfo.version;
};
function registry(opts = {}) {
    let requestsHeaders = {
        'user-agent': `oc-cli-${getOcVersion()}/${process.version}-${process.platform}-${process.arch}`
    };
    return {
        async add(registry) {
            if (registry.slice(registry.length - 1) !== '/') {
                registry += '/';
            }
            try {
                const apiResponse = await (0, got_1.default)(registry, {
                    headers: requestsHeaders
                }).json();
                if (!apiResponse)
                    throw 'oc registry not available';
                if (apiResponse.type !== 'oc-registry')
                    throw 'not a valid oc registry';
                const res = await fs_extra_1.default
                    .readJson(settings_1.default.configFile.src)
                    .catch(() => ({}));
                if (!res.registries) {
                    res.registries = [];
                }
                if (!lodash_1.default.includes(res.registries, registry)) {
                    res.registries.push(registry);
                }
                return fs_extra_1.default.writeJson(settings_1.default.configFile.src, res);
            }
            catch (err) {
                throw 'oc registry not available';
            }
        },
        async get() {
            if (opts.registry) {
                return [opts.registry];
            }
            try {
                const res = await fs_extra_1.default.readJson(settings_1.default.configFile.src);
                if (!res.registries || res.registries.length === 0)
                    throw 'No oc registries';
                return res.registries;
            }
            catch (err) {
                throw 'No oc registries';
            }
        },
        getApiComponentByHref(href) {
            return (0, got_1.default)(href + settings_1.default.registry.componentInfoPath, {
                headers: requestsHeaders
            }).json();
        },
        async getComponentPreviewUrlByUrl(componentHref) {
            const res = await (0, got_1.default)(componentHref, { headers: requestsHeaders }).json();
            const parsed = urlParser.parse(res);
            return urlBuilder.componentPreview(parsed, parsed.registryUrl);
        },
        async putComponent(options) {
            if (!!options.username && !!options.password) {
                requestsHeaders = Object.assign(requestsHeaders, {
                    Authorization: 'Basic ' +
                        Buffer.from(options.username + ':' + options.password).toString('base64')
                });
            }
            try {
                await (0, put_1.default)(options.route, options.path, requestsHeaders);
            }
            catch (err) {
                let parsedError = err.response.body || err;
                let errMsg = '';
                if (!lodash_1.default.isObject(parsedError)) {
                    try {
                        parsedError = JSON.parse(String(parsedError));
                    }
                    catch (er) { }
                }
                if (!!parsedError.code && parsedError.code === 'ECONNREFUSED') {
                    errMsg = 'Connection to registry has not been established';
                }
                else if (parsedError.code !== 'cli_version_not_valid' &&
                    parsedError.code !== 'node_version_not_valid' &&
                    !!parsedError.error) {
                    errMsg = parsedError.error;
                }
                else {
                    errMsg = parsedError;
                }
                throw errMsg;
            }
        },
        async remove(registry) {
            if (registry.slice(registry.length - 1) !== '/') {
                registry += '/';
            }
            const res = await fs_extra_1.default
                .readJson(settings_1.default.configFile.src)
                .catch(() => ({ registries: [] }));
            res.registries = lodash_1.default.without(res.registries, registry);
            await fs_extra_1.default.writeJson(settings_1.default.configFile.src, res);
        }
    };
}
exports.default = registry;
