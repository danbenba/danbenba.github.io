"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const get_missing_dependencies_1 = __importDefault(require("./get-missing-dependencies"));
const index_1 = __importDefault(require("../../../resources/index"));
const strip_version_1 = __importDefault(require("../../../utils/strip-version"));
async function linkMissingDependencies(options) {
    const { componentPath, dependencies, logger } = options;
    const missingDependencies = (0, get_missing_dependencies_1.default)(dependencies);
    if (!missingDependencies.length) {
        return;
    }
    logger.warn(index_1.default.messages.cli.LINKING_DEPENDENCIES(missingDependencies.join(', ')), true);
    const symLinkType = 'dir';
    for (const dependency of missingDependencies) {
        const moduleName = (0, strip_version_1.default)(dependency);
        const pathToComponentModule = path_1.default.resolve(componentPath, 'node_modules', moduleName);
        const pathToModule = path_1.default.resolve('.', 'node_modules', moduleName);
        try {
            await fs_extra_1.default.ensureSymlink(pathToComponentModule, pathToModule, symLinkType);
        }
        catch (err) {
            logger.err(index_1.default.errors.cli.DEPENDENCY_LINK_FAIL(moduleName, String(err)));
            throw index_1.default.errors.cli.DEPENDENCIES_LINK_FAIL;
        }
    }
}
exports.default = linkMissingDependencies;
