"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const settings_1 = __importDefault(require("../../resources/settings"));
const resources_1 = __importDefault(require("../../resources/"));
const isMockValid = (plugin) => {
    const isFunction = typeof plugin === 'function';
    const isValidObject = !!plugin &&
        typeof plugin === 'object' &&
        typeof plugin.register === 'function' &&
        typeof plugin.execute === 'function';
    return isFunction || isValidObject;
};
const defaultRegister = (_options, _dependencies, next) => {
    next();
};
const registerStaticMocks = (mocks, logger) => Object.entries(mocks).map(([pluginName, mockedValue]) => {
    logger.ok(`├── ${pluginName} () => ${mockedValue}`);
    return {
        name: pluginName,
        register: {
            register: defaultRegister,
            execute: () => mockedValue
        }
    };
});
const registerDynamicMocks = (ocJsonLocation, mocks, logger) => Object.entries(mocks)
    .map(([pluginName, source]) => {
    let pluginMock;
    try {
        pluginMock = require(path_1.default.resolve(ocJsonLocation, source));
    }
    catch (er) {
        logger.err(String(er));
        return;
    }
    if (!isMockValid(pluginMock)) {
        logger.err(`├── ${pluginName} () => Error (skipping)`);
        logger.err(resources_1.default.errors.cli.MOCK_PLUGIN_IS_NOT_VALID);
        return;
    }
    const register = pluginMock.register || defaultRegister;
    const execute = pluginMock.execute || pluginMock;
    logger.ok(`├── ${pluginName} () => [Function]`);
    return {
        name: pluginName,
        register: { execute, register }
    };
})
    .filter((pluginMock) => !!pluginMock);
const findPath = (pathToResolve, fileName) => {
    const rootDir = fs_extra_1.default.realpathSync('.');
    const fileToResolve = path_1.default.join(pathToResolve, fileName);
    if (!fs_extra_1.default.existsSync(fileToResolve)) {
        if (pathToResolve === rootDir) {
            return undefined;
        }
        else {
            const getParent = (pathToResolve) => pathToResolve.split('/').slice(0, -1).join('/');
            const parentDir = pathToResolve ? getParent(pathToResolve) : rootDir;
            return findPath(parentDir, fileName);
        }
    }
    return fileToResolve;
};
function getMockedPlugins(logger, componentsDir) {
    componentsDir = path_1.default.resolve(componentsDir || '.');
    let plugins = [];
    const ocJsonFileName = settings_1.default.configFile.src.replace('./', '');
    const ocJsonPath = findPath(componentsDir, ocJsonFileName);
    if (!ocJsonPath) {
        return plugins;
    }
    const content = fs_extra_1.default.readJsonSync(ocJsonPath);
    const ocJsonLocation = ocJsonPath.slice(0, -ocJsonFileName.length);
    if (!content.mocks || !content.mocks.plugins) {
        return plugins;
    }
    logger.warn(resources_1.default.messages.cli.REGISTERING_MOCKED_PLUGINS);
    plugins = plugins.concat(registerStaticMocks(content.mocks.plugins.static ?? {}, logger));
    plugins = plugins.concat(registerDynamicMocks(ocJsonLocation, content.mocks.plugins.dynamic ?? {}, logger));
    return plugins;
}
exports.default = getMockedPlugins;
